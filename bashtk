#!/bin/bash
# BASHTK: BASH Toolkit
#
# A library of BASH utility routines.
# -----------------------------------
# Copyright 2011 Rajiv Narayan
# -----------------------------------
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Current version
BTK_VERSION="1.0-rc1"
# Path to bashtk script
#BASHTK_PATH=`type -p bashtk`
# works with bash >= v3
BTK_PATH=$BASH_SOURCE

# global variables used by various functions.
# Note changing these directly can have unintended effects.
BTK_TIC='' #timer count
BTK_ENABLE_LOG=0 #enable logging
BTK_LOG_FILE='' #log filename
BTK_LOG_DATE_FORMAT='%b %e %H:%M:%S' #date format for log
BTK_DEBUG=0 #enable / disable debug messages
BTK_BCSCALE=4 #precision for bc calculator

usageHelp="\033[1;4;34mBashTk: BASH Toolkit v$BTK_VERSION\033[0m
A library of BASH utility routines.
Copyright 2011 Rajiv Narayan

Usage: bashtk [options]
Options:
-q Quiet mode. Do not print any message when sourced
-h Print this help message and exit

To use the library, simply source the file using:
source $BTK_PATH

Type \033[0;32mbtkhelp\033[0m for a list of available commands.
"
#test_help=('check_help' '$1' '$FUNCNAME' '||' 'return 1')
#CHECK_HELP=('eval if [[ $1 == -h ]]; then btkhelp $FUNCNAME; return 1; fi')  
CHECK_HELP=('')
check_help()
{
    if [[ $1 == -h ]]; then 
	btkhelp $2
	return 1; 
    fi
}
btkhelp()
{
    echo -e "\033[1;4;34mBashTk: BASH Toolkit v$BTK_VERSION\033[0m"
    if [[ -z $1 ]]; then
	echo "List of available commands:"
	awk '
/^### .*/ {gsub ("^#* *",""); print "\033[4;1;31m""\n"$0"\033[0m";}
/^## / {gsub ("^#* *",""); split($0,a,":"); print "\033[1;32m"a[1]"\033[0m"a[2];}
' $BTK_PATH
	echo
	echo "Type <command> -h or btkhelp <command> for help on a specific command."
    else
	awk -v pat="^## $1:" '$0~pat,!/^#.*/{
if ($0~pat) {gsub("^#* *",""); split($0,a,":"); print "\033[0;32m"a[1]"\033[0m"a[2];} 
else if (/^#.*/) {gsub("^#* *","  "); print};
}' $BTK_PATH
	echo
	echo "Type btkhelp for a list of available commands"|colorize 'btkhelp'
    fi
}

#########################
### Date / Time functions
#########################

## tic: Start timer.
#  Usage: tic
#  Initializes the timer. Use toc to get the time elapsed.
#  See also: toc 
tic () 
{
    check_help $1 $FUNCNAME || return 1
    BTK_TIC=$(date +%s)
}

## toc: Print time elapsed in seconds.
#  Usage: toc
#  Prints the seconds elapsed since tic was called. Note must first
#  call tic before calling toc
#
#  Example:
#  tic
#  echo "do something"
#  elapsed=$(toc)
#  echo "${elapsed}s elapsed."
toc()
{
    check_help $1 $FUNCNAME || return 1
    local _TOC=$(date +%s)
    if [[ -n $BTK_TIC ]]; then
	local SECS_ELAPSED=$(($_TOC - $BTK_TIC))
	echo "${SECS_ELAPSED}"
	return 0
    else
	echo "Run tic() before calling toc()"
	return 1
    fi
}

##################
### File utilities
##################

## absPath: Resolve the absolute path to a file.
#  Usage: absPath filename 
#  Prints the resolved path
#
#  Example:
#  absPath ~/myfile.txt
absPath()
{
    check_help $1 $FUNCNAME || return 1
    local p="$1"
    local d="$(dirname -- "$p")"
    if [[ $d == '~' ]]; then
	d=$(readlink -f ~)
    else
	d=$(cd -P -- "$d" 2&>/dev/null && pwd -P)
    fi
    fullFile "$d" "$(basename $p)"

#    if ( require realpath); then
#	realpath -s "$p"
#    elif ( require python); then
#	python -c "import os,sys; print os.path.realpath(sys.argv[1])" "$prg"
#    fi
}

## dirCheck: Check if folder exists.
#  Usage: dirCheck dirname 
#  If dirname does not exist, prints an error and exits
dirCheck()
{
    check_help $1 $FUNCNAME || return 1
    [[ ! -d "$1" ]] && printErrorAndExit "Folder:$1 missing"
}

# fileCheck: Check if file exists
#  Usage: fileCheck FILENAME
#  If FILENAME does not exist, prints error and exits
fileCheck()
{
    check_help $1 $FUNCNAME || return 1
    [[ ! -f "$1" ]] && printErrorAndExit "File:$1 missing"
}

## fileParts: Split a file into path, file and extension.
#  Usage: fileParts FILENAME
#  Prints the path, file and extension of FILENAME. Can be read into
#  an array.
#
#  Example
#  parts=(`fileParts ~/file.txt`)
#  echo "path:${parts[0]} file:${parts[1]} ext:${parts[2]}"
fileParts() 
{
    check_help $1 $FUNCNAME || return 1
    local f="$1"
    if ! $(isEmpty "$f"); then
	local bn=$(basename $f)
	local dn=$(dirname $f)
	echo $dn
	echo ${bn%%\.*}
	local ext=${bn#*\.}
	if [ "$ext" != "$bn" ]; then
	    echo ".$ext"
	else
	    echo ""
	fi
	return 0 #success
    else
	return 1 #fail
    fi
}

## fullFile: Build full filename from parts.
#  Usage: fullFile D1 D2 ... FILE
#
#  Example:
#  fullFile foo bar zog.txt
fullFile()
{
    check_help $1 $FUNCNAME || return 1
    local f="$1"
    shift 1
    for part in $@
    do
	if [ -z "$f" -a -z "$part" ]; then
	    f="$f$part"
	elif [ "${f:(-1):1}" == '/' -a "${part:1:1}" == '/' ]; then 
	    f="$f${part:1}"
	elif [ "${f:(-1):1}" == '/' -o "${part:1:1}" == '/' ]; then
	    f="$f$part"
	else
	    f="$f/$part"
	fi
    done
    echo $f
    return 0 #success
}

## isDir: Test if directory exists.
#  Usage: isDir DIRNAME
#  Returns an exit code of 0 if DIRNAME exists or 1 otherwise
#
# Example
# if ! (isDir myfolder); then echo 'folder does not exist'; fi
isDir()
{
    check_help $1 $FUNCNAME || return 1
    [[ -d $1 ]]
}

## isFile: Test if file exists.
#  Usage: isFile FILENAME
#  Returns an exit code of 0 if FILENAME exists or 1 otherwise
#
#  Example 
#  if (isFile myfile.txt); then echo 'file exists'; fi
isFile()
{
    check_help $1 $FUNCNAME || return 1
    [[ -f $1 ]]
}

## require: Test if a command is available.
#  Usage: require CMD
#  Returns an exit code of 0 if CMD exists or >0 otherwise
#
#  Example:
#  if (require ls); then echo 'ls exists'; fi
require () 
{ 
    check_help $1 $FUNCNAME || return 1
    type -p "$1" 2>&1 >/dev/null
}

################
### IO functions
################
## file2array: Read a text file into an array.
#  Usage: file2array FILENAME
#  Reads each line in FILENAME into an array
#  Example
#  x=(`file2array foo.txt`)
#  echo "number of elements:" ${#x[@]}
#  echo ${x[@]}
file2array()
{
    check_help $1 $FUNCNAME || return 1
    local f="$1"
    if isFile $f; then
	local arr=(`cat "$f"|egrep -v '^$|^#'|tr '\n' ' '`)
	for e in "${arr[@]}";
	do
	    echo $e
	done	
    fi
}

## file2list: Read a text file into an list.
#  Usage: file2list FILENAME
#  Reads each line in FILENAME into a list. Blank lines and lines
#  beginning with a '#' are ignored.
#
#  Example:
#  x=(`file2list foo.txt`)
#  echo ${x[@]}
file2list()
{
    check_help $1 $FUNCNAME || return 1
    local f="$1"
    if isFile $f; then
	echo `cat "$f"|egrep -v '^$|^#'|tr '\n' ' '`
    fi
}

## input: Read input from stdin, pipes or files.
#  Usage: [PIPE|] input [STDIN] [<FILE]
#  Returns data from standard input, file redirection or pipe.
#  
#  Example:
#  echo 1 2 3 | input
#  input 1 2 3
#  input < file.txt
#  #Read into an array
#  in=(`input "$@"`)
input()
{
    #check_help $1 $FUNCNAME || return 1
    local SAVEIFS=$IFS
    IFS=$(echo -en "\n\b")
    local x=( "$@" )
    if [[ ${#x[@]} -eq 0 ]]; then
	if isPipeIn || ! isStdIn; then
	    x=(`while read -r l; do echo "$l"; done`)	    
	fi
    fi
    echo "${x[@]}"
    IFS=$SAVEIFS
}

inputType()
{
    local t='no input'
    local x=( "$@" )
    if [[ ${#x[@]} -gt 0 ]]; then
	t='stdin'
    elif isPipeIn; then
	t='pipe'
    elif ! isStdIn; then
	t='file'
    fi
    echo $t
}

## isFileIn: Test if script received a file redirection input.
#  Usage: isFileIn
#  Returns 0 if a file redirection input was detected, 1 if not
isFilein()
{
    check_help $1 $FUNCNAME || return 1
    if ! isPipeIn && ! isStdin; then
	return 0
    else
	return 1
    fi
}

## isLinux: Test for GNU linux.
#  Usage: isLinux
#  Returns 0 for linux and 1 otherwise.
isLinux()
{
    check_help $1 $FUNCNAME || return 1
    [[ $OSTYPE =~ linux ]]
}

## isMac: Test for Mac OS X.
#  Usage: isMac
#  Returns 0 for Mac and 1 otherwise.
isMac()
{
    check_help $1 $FUNCNAME || return 1
    [[ $OSTYPE =~ darwin ]]
}

## isPipeIn: Test if script received a pipe input.
#  Usage: isPipeIn
#  Returns 0 if a pipe input was detected, 1 if not
isPipeIn()
{
    check_help $1 $FUNCNAME || return 1
    if isLinux; then
	local src=$(readlink /proc/self/fd/0)
	if [[ $src =~ ^pipe: ]]; then
	    return 0
	fi
    elif isMac; then
	x=$(stat -f %HT /dev/fd/0)
	if [[ $x =~ 'Fifo' ]]; then
	    return 0
	fi
    fi
    return 1
}

## isStdIn: Test if script received standard input.
#  Usage: isStdIn
#  Returns 0 if a standard input was detected, 1 if not
isStdIn()
{
    check_help $1 $FUNCNAME || return 1
    if isLinux; then
	local src=$(file `readlink /proc/self/fd/0`)
	if [[ $src =~ character\ special ]]; then
	    return 0
	fi
    elif isMac; then
	x=$(stat -f %HT /dev/fd/0)
	if [[ $x =~ 'Character' ]]; then
	    return 0
	fi
    fi
    return 1
}

# data structures
# TODO: hash table : 
# http://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash

#################
### Logical Tests
#################

## isDefined: Test if variable exists.
#  Example:
#  y='foo'
#  unset x
#  isDefined $y && echo 'y is defined'
#  ! isDefined $x && echo 'x is not defined'
isDefined()
{
    check_help $1 $FUNCNAME || return 1
    #[[ ${!1-X} == ${!1-Y} ]]
    [[ ! -z "${1+x}" ]]
}

## isEmpty: Test if a string is empty.
# example 
# if (isEmpty "foo"); then echo 'string is not empty'; fi
isEmpty()
{
    check_help $1 $FUNCNAME || return 1
    [[ -z $1 ]]
}

## isInteger: Test if a variable is an integer.
#  Usage: isInteger VAR
#
#  if isInteger -10; then echo 'is an integer'; fi 
isInteger()
{
    check_help $1 $FUNCNAME || return 1
    [ "$1" -eq "$1" 2>/dev/null ]
    #[[ $1 -eq $1 ]] 2>/dev/null
}

## isInteractive: Test if current shell is interactive.
#  Usage: isInteractive
#  Returns 0 as an exit code if true, 1 if not.
isInteractive()
{
    [[ $- =~ 'i' ]]
# alternatively
#    [[ -n "$PS1" ]]
}

## isNumeric: Test if a variable is numeric.
#  Usage: isNumeric VAR
#  Returns an exit code of 0 if VAR is numeric or 1 if not.
#  Example:
#  if (isNumeric 10.5); then echo 'is a number'; fi
isNumeric()
{
    check_help $1 $FUNCNAME || return 1
    [[ `awk -v var="$1" 'BEGIN{print var==var+0}'` -eq 1 ]]
}

##################
### Math utilities
##################

## abs: Absolute value.
#  Usage: abs N1 [N2] ...
#  Computes the absolute value of a list of numbers.

#TODO: test if numeric
abs()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    if [[ ${#x[@]} -gt 0 ]]; then
        echo ${x[@]}|awk '{for(i=1;i<=NF;i++){print ($i>=0) ? $i : -$i;}}'
        return 0
    else
        return 1
    fi
}

## calc: Evaluate a floating point number expression.
#  Usage: calc EXPRESSION
#  Evaluates EXPRESSION using bc. Writes the result of EXPRESSION to
#  standard out. Sets exit code to 0 if the expression was evaluated
#  successfully and 1 if not. Refer to the man page of bc to see
#  available functions.
#
#  Example: 
#  calc 'sqrt(2) / 3.0' 
#
#  See also: float_cond

# Modified from: http://www.linuxjournal.com/content/floating-point-math-bash
function calc()
{
    check_help $1 $FUNCNAME || return 1
    local stat=0
    local result=0.0
    local e=(`input "$@"`)
    if [[ "${#e[@]}" -gt 0 ]]; then
        result=$(echo "scale=$(getBCScale); ${e[@]}" | bc -q -l 2>/dev/null)
        stat=$?
        if [[ $stat -eq 0  &&  -z "$result" ]]; then stat=1; fi
    fi
    echo $result
    return $stat
}

## ceil: Round up to positive infinity.
#  Usage: ceil N1 [N2] ...
#  Returns the smallest integer that is not less than N1.
ceil() { 
    check_help $1 $FUNCNAME || return 1
# BC solution
# See http://stackoverflow.com/questions/2726896/bash-bcmath-functions
    local x=( `input "$@"` )
    local BC_CEIL="define ceil(x) { auto savescale; savescale = scale;
    scale = 0; if (x>0) { if (x%1>0) result = x+(1-(x%1)) else result
    = x} else result = -1*floor(-1*x); scale = savescale; return
    result }"
    local BC_FLOOR="define floor(x) { auto savescale; savescale =
    scale; scale = 0; if (x>0) result = x-(x%1) else result =
    -1*ceil(-1*x); scale = savescale; return result }" 
# An Alternative Python soluton
#    python -c "import sys; from math import ceil; print
#    ceil(float(sys.argv[1]))" $e

    for e in "${x[@]}"; do
	if (isNumeric $e); then
	    echo -e "scale=$(getBCScale)\n"$BC_CEIL$BC_FLOOR"ceil($e)"|bc
	else
	    echo "Error $e is not numeric"
	    return 1
	fi
    done
    return 0
}

## float_cond: Evaluate a floating point number conditional expression.
#  Usage: float_cond CONDITIOAL_EXPRESSION
#  Evaluates CONDITIONAL_EXPRESSION and sets the return/status code to
#  zero if the expression is true and one if it's false.
#  Example: if (float_cond '12.0 > 3.0'); then echo true; fi
#  See also: float_eval

# Modified from: http://www.linuxjournal.com/content/floating-point-math-bash
function float_cond()
{
    check_help $1 $FUNCNAME || return 1
    local cond=0
    local e=(`input "$@"`)
    if [[ ${#e[@]} -gt 0 ]]; then
        cond=$(echo "${e[@]}" | bc -q 2>/dev/null)
        if [[ -z "$cond" ]]; then cond=0; fi
        if [[ "$cond" != 0  &&  "$cond" != 1 ]]; then cond=0; fi
    fi
    local stat=$((cond == 0))
    return $stat
}

## floor: Round down value.
#  Usage: floor N1 [N2] ...
#  Returns the largest integer that is not greater than N.
floor() { 
    check_help $1 $FUNCNAME || return 1
# BC solution
# See http://stackoverflow.com/questions/2726896/bash-bcmath-functions
    local x=( `input "$@"` )
    local BC_CEIL="define ceil(x) { auto savescale; savescale = scale;
    scale = 0; if (x>0) { if (x%1>0) result = x+(1-(x%1)) else result
    = x} else result = -1*floor(-1*x); scale = savescale; return
    result }"
    local BC_FLOOR="define floor(x) { auto savescale; savescale =
    scale; scale = 0; if (x>0) result = x-(x%1) else result =
    -1*ceil(-1*x); scale = savescale; return result }" 

    for e in "${x[@]}"; do
	if (isNumeric $e); then
	    echo -e "scale=$(getBCScale)\n"$BC_CEIL$BC_FLOOR"floor($e)"|bc
	else
	    echo "Error $e is not numeric"
	    return 1
	fi
    done
    return 0
}

## getBCScale: Get the current scale setting for BC.
#  Usage: getBCScale
#  Default is 4
#  See also setBCScale 
getBCScale()
{
    check_help $1 $FUNCNAME || return 1
    echo ${BTK_BCSCALE}
}

## length: Length of a list.
#  Usage: length L1 L2 L3 ...
length()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    echo ${#x[@]}
    return 0
}

## log2: Base 2 logarithm.
#  Usage: log2 N1 N2 N3 ...
log2()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    for e in ${x[@]}; do
	echo "scale=$(getBCScale); l($e)/l(2)"|bc -l
    done
}

## max: Calculate the maximum of a list of numbers.
max()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    if [[ ${#x[@]} -gt 0 ]]; then
	echo ${x[@]}|awk '{max=$1; for(i=1;i<=NF;i++){if ($i>max) {max=$i;}}; print max}'
	return 0
    else
	return 1
    fi
}

## mean: Compute the average of a list of numbers.
#  Usage: mean N1 N2 N3 ...
#  Returns the mean of the list. The precision of the result is
#  determined by setBCScale.
#  See also: setBCScale
mean()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    echo "scale=$(getBCScale);" $(sum "${x[@]}")/${#x[@]}|bc
}

## min: Calculate the minimum of a list of numbers.
min()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    if [[ ${#x[@]} -gt 0 ]]; then
	echo ${x[@]}|awk '{min=$1; for(i=1;i<=NF;i++){if ($i<min) {min=$i;}}; print min}'
	return 0
    else
	return 1
    fi
}

## pi: Value of PI.
#  Usage: pi
#  Prints the value of PI. The precision is determined by setBCScale.
#
#  See also setBCScale
pi()
{
    check_help $1 $FUNCNAME || return 1
    echo "scale=$(getBCScale); 4*a(1)"| bc -l 
}

## pow2: Base 2 power of numbers.
#  Usage: pow2 N1 N2 N3 ...
#  Calculates 2^N for a list of numbers.
pow2()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    for e in ${x[@]}; do
	if (isInteger $e); then
	    echo "scale=$(getBCScale); 2^$e"|bc
	else
	    echo "scale=$(getBCScale); e($e*l(2))"|bc -l
	fi
    done
}

## rand: Generate random numbers.
#  Usage: rand [N]
#  Generates one random number in the range [0,1]. Generates N value
#  if specified.
rand()
{
   check_help $1 $FUNCNAME || return 1
   local n=${1:-1}
   if require awk; then
       local x=(`awk -v N=$n 'BEGIN{srand(); for (i=0;i<N;i++){print rand();}}'`)
   else
       # polling /dev/urandom is inefficient, and should not be used
       # for long sequences
       local i=0
       while [[ $i -le $n ]];
       do
	   x[$i]=`echo "scale=$(getBCScale);"$(od -N3 -An -i /dev/urandom)'/16777216'|bc`
           ((i++))
       done
   fi
   echo "${x[@]}"
}

## round: Round to nearest integer.
#  Usage: round N1 [N2] ...
round()
{
    check_help $1 $FUNCNAME || return 1
    BC_ROUND="define round(x) { scale=0; if (x>0) return (x+0.5)/1
    else return (x-0.5)/1 }"
    local x=( `input "$@"` )
    for e in "${x[@]}"
    do
      if (isNumeric $e); then
	 echo $BC_ROUND"round($e)"|bc
      else
	  echo "Error $e is not numeric"
	  return 1
      fi
    done
    return 0
}

## setBCScale: Set the precision for BC output.
#  Usage: setBCScale integer
#  If called without and argument defaults to 4.
#  See also getBCScale
setBCScale()
{
    check_help $1 $FUNCNAME || return 1
    BTK_BCSCALE=${1:-4}
}

## sign: Signum function.
#  Usage: sign N1 [N2] ...
#  Returns 1 if the number is positive, -1 if its negative and 0 if it
#  is equal to zero.
sign()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    for e in "${x[@]}"
    do
      if (isNumeric $e); then
	  if ( float_cond "$e > 0" ); then
	      echo 1
	  elif ( float_cond "$e < 0" ); then
	      echo -1
	  else
	      echo 0
	  fi
      else
	  echo "Error $e is not numeric"
	  return 1
      fi
    done
    return 0
}

## sqrt: Square root of non-negative numbers.
#  Usage: sqrt N1 [N2] ...
sqrt()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    for e in ${x[@]}; do
        if (float_cond "$e>=0"); then
            echo "scale=$(getBCScale); sqrt($e)"|bc
        else
	    echo "$e is negative"
	    return 1
        fi
    done
    return 0
}

## std: Standard deviation.
#  Usage: std X1 X2 ...
std()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    if [[ ${#x[@]} -gt 1 ]]; then
	local mu=$(mean "${x[@]}")
	local sigma
	sigma=$(echo "${x[@]}" | awk -v mean=$mu '
{for (i=1;i<=NF;i++) {sum2+=($i - mean)*($i - mean);}} 
END{print sqrt(sum2/(NF - 1))}')
	echo $sigma
    else
	echo 0
    fi
}

## sum: Calculate the sum of elements in a list.
#  Usage: sum N1 N2 N3 ...
#  Prints the sum of numbers in the list.
#  Example:
#  x={1..5}
#  sum ${x[@]}

sum()
{
    check_help $1 $FUNCNAME || return 1
    #check_help $1 $FUNCNAME
    local x=( `input "$@"` )
    echo "${x[@]}"|awk '{for(i=1;i<=NF;i++){s+=$i}; print s}'
    return 0
}

## var: Variance
#  Usage X1 X2 ...
var()
{
    check_help $1 $FUNCNAME || return 1
    local x=( `input "$@"` )
    local mu=$(mean "${x[@]}")
    local v
    v=$(echo "${x[@]}" | awk -v mean=$mu ' 
{for (i=1;i<=NF;i++) {sum2+=+($i - mean)*($i - mean);}} 
END{print sum2/(NF - 1)}')
    echo $v
}

# prctile

######################
### Messages and Logging
######################

# _getAttrValue: Get terminal attribute values. 
# private function
_getAttrValue()
{
    check_help $1 $FUNCNAME || return 1
    local val=''
    local stat=0
    case "$1" in
	BLACK) val=0;;
	RED) val=1;;
	GREEN) val=2;;
	YELLOW) val=3;;
	BLUE) val=4 ;;
	MAGENTA) val=5;;
	CYAN) val=6;;
	WHITE) val=7;;
	DEFAULT) val='sgr0';;
	RESET) val='sgr0';;
	BOLD) val='bold';;
	UNDERLINE) val='smul';;
	BLINK) val='blink';;
	REVERSE) val='rev';;
	*) stat=1;;
    esac
    echo $val
    return $stat
}

## bail: Exit on error.
#  Usage: bail MESSAGE
#  Checks the exit status of the last command and prints MESSAGE and
#  exits if status is non-zero.  Returns the status as the exit code.
bail()
{
    if [[ $? -gt 0 ]]; then
	{
	    [[ -n "$@" ]] && echo "$@"
	    quit 1
	}
    fi
    return 0
}

## color: Set terminal color and attributes.
#  Usage: color FGCOLOR [ATTR1] ...
#  Set terminal foreground color to FGCOLOR and sets optional
#  attributes ATTR. Colors can be one of [red, green, yellow, blue,
#  magenta, cyan, white, black]. ATTR can be [bold, underline,
#  reverse]. Calling color without arguments or setting COLOR to
#  'reset' sets the color to the default.
#
#  Example:
#  color red
#  color red underline reverse
#
#  See also: colorBG
color()
{
    check_help $1 $FUNCNAME || return 1
    local fgcol=$(upper "$1")
    fgcol=${fgcol:-RESET}
    bgcol=${bgcol:-RESET}
    shift $(min 1 $#)
    local fgval=$(_getAttrValue $fgcol)

    if [[ $# -gt 0 ]]; then
	local effect=(`upper "$@"`)
	for e in "${effect[@]}"; do
	    local effectval=$(_getAttrValue $e)
	    if [[ -n $effectval ]]; then
		tput $effectval
	    fi
	done
    fi

    if [[ $fgcol == 'DEFAULT' || $fgcol == 'RESET' ]]; then
	tput $fgval
    else
	if [[ -n $fgval ]]; then 
	    tput setaf $fgval
	fi
    fi

}

## colorBG: Set terminal foreground, background color and attributes.
#  Usage: colorBG FGCOLOR [BGCOLOR] [ATTR1] ...
#  Set terminal foreground color to FGCOLOR, background color to
#  BGCOLOR and sets optional attributes ATTR. Colors can be one of
#  [red, green, yellow, blue, magenta, cyan, white, black]. ATTR can
#  be [bold, underline, reverse]. Calling color without arguments or
#  setting COLOR to 'reset' sets the color to the default.
#
#  Example:
#  color red 
#  color red white bold underline
#
#  See also: color
colorBG()
{
    check_help $1 $FUNCNAME || return 1
    local fgcol=$(upper "$1")
    local bgcol=$(upper "$2")
    fgcol=${fgcol:-RESET}
    bgcol=${bgcol:-RESET}
    shift $(min 2 $#)
    local effect=(`upper "$@"`)
    color $fgcol "${effect[@]}"
    local bgval=$(_getAttrValue $bgcol)
    if [[ -n $bgval ]]; then
	tput setab $bgval
    fi
}

## log: Write a message to a logfile.
#  Usage log MSG
#  Writes MSG to the logfile specified by logon. Note will fail
#  silently if logging has not been enabled.
#  See also: logon, logoff, msg
log()
{
    check_help $1 $FUNCNAME || return 1
    if [[ $BTK_ENABLE_LOG -eq 1 ]]; then
	local m="$@"
	local ts=`date +"$BTK_LOG_DATE_FORMAT"`
	if [[ -n $m ]]; then
	    echo "$ts $m" >> "$BTK_LOG_FILE"
	else
	    echo "$ts -- Empty message --" >> "$BTK_LOG_FILE"
	fi
    fi
}

## logcat: Display contents of the log file.
#  Usage: logcat
logcat()
{
    check_help $1 $FUNCNAME || return 1
    if [[ $BTK_ENABLE_LOG -eq 1 ]]; then
	cat "$BTK_LOG_FILE"
    else
	echo "Logging not enabled"
    fi
}

## logname: Displays path of the current logfile.
#  Usage: logname
logname()
{
    check_help $1 $FUNCNAME || return 1
    if [[ $BTK_ENABLE_LOG -eq 1 ]]; then
	echo "$BTK_LOG_FILE"
    else
        echo "Logging not enabled"
    fi
}

## logoff: Stop logging to file.
#  Usage: logoff [MSG]
#  Write End log message to log and stops logging. 
#  See also: logon
logoff()
{
    check_help $1 $FUNCNAME || return 1
    local m="${@:---- End log ---}"
    log "$m"
    logsuspend
}

## logon: Begin logging to file.
#  Usage: logon LOGFILE
#  Turns on logging and specifies the logfile. All subsequent calls to
#  msg or log will be written to the logfile.
#  See also: logoff, log
logon()
{
    check_help $1 $FUNCNAME || return 1
    if [[ -n $1 ]]; then
	BTK_LOG_FILE="$1"
	touch "$BTK_LOG_FILE"
	BTK_ENABLE_LOG=1
	log '--- Begin log ---'
    else
	echo "logon: must specify logfile"
    fi
}

## logreset: Resets the content of the current logfile.
#  Usage: logreset
logreset()
{
    check_help $1 $FUNCNAME || return 1
    if [[ $BTK_ENABLE_LOG -eq 1 ]]; then
	rm -f "$BTK_LOG_FILE"
	logon "$BTK_LOG_FILE"
    else
        echo "Logging not enabled"
    fi
}

## logresume: Resume logging to file.
#  Usage: logresume
#  See also: logsuspend
logresume()
{
    check_help $1 $FUNCNAME || return 1
    if [[ $BTK_ENABLE_LOG -eq 0 && -f $BTK_LOG_FILE ]]; then
	logon "$BTK_LOG_FILE"
    elif [[ ! -f $BTK_LOG_FILE ]]; then
	echo 'Logfile does not exist, cannot resume.'
    fi
}

## logsuspend: Temporarily stop logging to file.
#  Usage: logsuspend
#  See also: logresume
logsuspend()
{
    check_help $1 $FUNCNAME || return 1
    BTK_ENABLE_LOG=0
}

## logtail: Display the last part of the logfile.
#  Usage: logtail [N]
#  Prints the last 10 lines of the log file. If N is specified prints
#  the last N lines.

logtail()
{
    check_help $1 $FUNCNAME || return 1
    local n=${1:-10}
    if [[ $BTK_ENABLE_LOG -eq 1 ]]; then
        tail -"$n" "$BTK_LOG_FILE"
    else
        echo "Logging not enabled"
    fi
}

## msg: Print and log messages.
#  Usage: msg TEXT [FGCOLOR] [ATTR]
#  Displays TEXT using optional attributes FGCOLOR and ATTR. Also
#  writes the message to logfile if logging is on.
#
#  Example:
#  msg 'This is an alert' red bold
#
#  See also: color, log
msg()
{
    check_help $1 $FUNCNAME || return 1
    local m="$1"
    shift
    color "$@"
    echo "$m"
    color reset
    log "$m"
}

## printErrorAndExit: Print error message and quit.
#  Usage: printErrorAndExit ERRMSG
#  Prints ERRMSG and exits with error code 1
printErrorAndExit()
{
    check_help $1 $FUNCNAME || return 1
    echo
    echo "Error: $@"
    echo
    quit 1
}

## printErrorHelpAndExit: Print error message, help and quit.
#  Usage: printErrorHelpAndExit ERRMSG
#  Prints ERRMSG and the variable usageHelp if it exists. Exits with
#  error code 1.
printErrorHelpAndExit()
{
    check_help $1 $FUNCNAME || return 1
    echo
    echo "Error: $@"
    echo
    printHelpAndExit
}

## printHelpAndExit: Display message and quit.
#  Usage: printHelpAndExit EXIT_CODE
#  Prints the variable $usageHelp if it exists and exits with
#  EXIT_CODE
printHelpAndExit()
{
    check_help $1 $FUNCNAME || return 1
    if isDefined $usageHelp; then
	echo -e "$usageHelp"
    fi
    quit 1
}

## quit: Exit with error code.
#  Usage: quit [EXIT CODE]
#  Replacement for exit. When called from a script exits with status 1
#  or EXIT CODE if specified.  In interactive mode, sends a SIGINT and
#  returns 1 or EXIT CODE.
quit()
{
    if isInteractive; then
	kill -s SIGINT $$
	return ${1:-1}
    else
	exit ${1:-1}
    fi
}

####################
### String Utilities
####################

## capitalize: Convert first letter of string to uppercase.
capitalize()
{
    check_help $1 $FUNCNAME || return 1
    local s="$(input "$@")"
    local f=`upper "${s:0:1}"`
    local r=`lower "${s:1}"`
    echo "$f$r"
}

## colorize: Highlight search terms.
#  Usage: PIPE | colorize TERM1 ...
#  Highlights each term in the input data.
colorize()
{
    check_help $1 $FUNCNAME || return 1
    local terms=( "$@" )
    local col='\033[1;31m'
    local reset='\033[0m'
    if isPipeIn; then
	while read l; do
	    for t in "${terms[@]}";
	    do
		l=`echo -e "${l//$t/${col}$t${reset}}"`
	    done
	    echo "$l"
	done
    fi
}

## lower: Convert string to lowercase.
lower()
{
    check_help $1 $FUNCNAME || return 1
    echo "$(input $@)" | tr '[:upper:]' '[:lower:]'
}

## strDeblank: Remove trailing spaces from the end of a string.
strDeblank()
{
    check_help $1 $FUNCNAME || return 1
    echo "$(input $@)" | sed 's/ *$//'
}

## strRep: Repeat a string.
#  Usage: strRep STR NREP [MAXLEN]
#  Repeats the string STR NREP times. If MAXLEN is specified truncates
#  the output at a maximum length.
strRep()
{
    check_help $1 $FUNCNAME || return 1
    local s="$1"
    local n="${2:-0}"
    local maxlen="$3"
    local x=''
    local i=0
    while [[ $i -le $n ]]
    do
	x+="$s"
	((i++))
    done
    if [[ -z $maxlen ]]; then
	echo "$x"
    else
	maxlen=$(min ${#x} $maxlen)
	echo "${x:0:$maxlen}"
    fi
}

## strTok: Split string into parts separated by a delimiter.
#  Usage: strTok -s STR -t DLM
#         PIPE | strTok -t DLM
#  Splits STR into parts based on the delimiter DLM. The delimiter
#  defaults to ' ' if not specified
#
#  Example
#  x=(`strTok -s 'foo:bar:abc' -t ':'`)
#  echo "number of parts:" ${#x[@]}
#  echo ${x[@]}
strTok()
{
    check_help $1 $FUNCNAME || return 1
    local tok=' '
    local s=(`input`)
    while getopts 't:s:' opt; do
	case "$opt" in
	    t) tok="$OPTARG";;
	    s) s="$OPTARG";;
	esac
    done
    local arr=$(echo "$s"| tr "$tok" '\n')
    for e in ${arr[@]}; do
	echo $e
    done
}

## strTrim: Remove leading and trailing spaces from a string.
strTrim()
{
    check_help $1 $FUNCNAME || return 1
    echo "$(input $@)" | sed 's/^ *//; s/ *$//'
}

## upper: Convert string to uppercase.
upper()
{
    check_help $1 $FUNCNAME || return 1 
    echo "$(input $@)" | tr '[:lower:]' '[:upper:]'
}

######
# Main
######
checkDep()
{
    local deps=( "$@" )
    for d in "${deps[@]}";
    do
      require $d
      if [ ! $? -eq 0 ]; then
	  echo "Warning: $d is missing. BashTk may not function
	  properly without it."
      fi
    done
}

# Check if dependencies exist
checkDep 'bc' 'python' 'awk' 'readlink' 'stat'
if [  "$BASH_SOURCE" != "$0" ]; then
    # library was sourced
    if [ "$1" != '-q' ]; then
	echo "Using BashTk v$BTK_VERSION"
    fi
else
    # Called directly
    if [ "$1" != '-q' ]; then
	printHelpAndExit
    fi
fi
